// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protocol.proto

#ifndef PROTOBUF_protocol_2eproto__INCLUDED
#define PROTOBUF_protocol_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3001000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3001000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace pool {
namespace proto {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_protocol_2eproto();
void protobuf_InitDefaults_protocol_2eproto();
void protobuf_AssignDesc_protocol_2eproto();
void protobuf_ShutdownFile_protocol_2eproto();

class Block;
class ClientStats;
class Data;
class Reply;
class ReqStats;
class Request;
class ServerInfo;
class ServerStats;
class Share;
class Signal;
class Work;

enum Signal_Type {
  Signal_Type_NEWBLOCK = 1,
  Signal_Type_SHUTDOWN = 2
};
bool Signal_Type_IsValid(int value);
const Signal_Type Signal_Type_Type_MIN = Signal_Type_NEWBLOCK;
const Signal_Type Signal_Type_Type_MAX = Signal_Type_SHUTDOWN;
const int Signal_Type_Type_ARRAYSIZE = Signal_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Signal_Type_descriptor();
inline const ::std::string& Signal_Type_Name(Signal_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Signal_Type_descriptor(), value);
}
inline bool Signal_Type_Parse(
    const ::std::string& name, Signal_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Signal_Type>(
    Signal_Type_descriptor(), name, value);
}
enum Request_Type {
  Request_Type_NONE = 0,
  Request_Type_CONNECT = 1,
  Request_Type_GETWORK = 2,
  Request_Type_SHARE = 3,
  Request_Type_STATS = 4,
  Request_Type_PING = 5
};
bool Request_Type_IsValid(int value);
const Request_Type Request_Type_Type_MIN = Request_Type_NONE;
const Request_Type Request_Type_Type_MAX = Request_Type_PING;
const int Request_Type_Type_ARRAYSIZE = Request_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Request_Type_descriptor();
inline const ::std::string& Request_Type_Name(Request_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Request_Type_descriptor(), value);
}
inline bool Request_Type_Parse(
    const ::std::string& name, Request_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Request_Type>(
    Request_Type_descriptor(), name, value);
}
enum Reply_ErrType {
  Reply_ErrType_NONE = 0,
  Reply_ErrType_VERSION = 1,
  Reply_ErrType_HEIGHT = 2,
  Reply_ErrType_REQNONCE = 3,
  Reply_ErrType_STALE = 4,
  Reply_ErrType_INVALID = 5,
  Reply_ErrType_DUPLICATE = 6
};
bool Reply_ErrType_IsValid(int value);
const Reply_ErrType Reply_ErrType_ErrType_MIN = Reply_ErrType_NONE;
const Reply_ErrType Reply_ErrType_ErrType_MAX = Reply_ErrType_DUPLICATE;
const int Reply_ErrType_ErrType_ARRAYSIZE = Reply_ErrType_ErrType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Reply_ErrType_descriptor();
inline const ::std::string& Reply_ErrType_Name(Reply_ErrType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Reply_ErrType_descriptor(), value);
}
inline bool Reply_ErrType_Parse(
    const ::std::string& name, Reply_ErrType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Reply_ErrType>(
    Reply_ErrType_descriptor(), name, value);
}
// ===================================================================

class Block : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pool.proto.Block) */ {
 public:
  Block();
  virtual ~Block();

  Block(const Block& from);

  inline Block& operator=(const Block& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Block& default_instance();

  static const Block* internal_default_instance();

  void Swap(Block* other);

  // implements Message ----------------------------------------------

  inline Block* New() const { return New(NULL); }

  Block* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Block& from);
  void MergeFrom(const Block& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Block* other);
  void UnsafeMergeFrom(const Block& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 height = 1;
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 1;
  ::google::protobuf::uint32 height() const;
  void set_height(::google::protobuf::uint32 value);

  // required string hash = 2;
  bool has_hash() const;
  void clear_hash();
  static const int kHashFieldNumber = 2;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  void set_hash(const char* value);
  void set_hash(const char* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // required string prevhash = 3;
  bool has_prevhash() const;
  void clear_prevhash();
  static const int kPrevhashFieldNumber = 3;
  const ::std::string& prevhash() const;
  void set_prevhash(const ::std::string& value);
  void set_prevhash(const char* value);
  void set_prevhash(const char* value, size_t size);
  ::std::string* mutable_prevhash();
  ::std::string* release_prevhash();
  void set_allocated_prevhash(::std::string* prevhash);

  // required uint32 reqdiff = 4;
  bool has_reqdiff() const;
  void clear_reqdiff();
  static const int kReqdiffFieldNumber = 4;
  ::google::protobuf::uint32 reqdiff() const;
  void set_reqdiff(::google::protobuf::uint32 value);

  // required uint32 minshare = 5;
  bool has_minshare() const;
  void clear_minshare();
  static const int kMinshareFieldNumber = 5;
  ::google::protobuf::uint32 minshare() const;
  void set_minshare(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pool.proto.Block)
 private:
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_hash();
  inline void clear_has_hash();
  inline void set_has_prevhash();
  inline void clear_has_prevhash();
  inline void set_has_reqdiff();
  inline void clear_has_reqdiff();
  inline void set_has_minshare();
  inline void clear_has_minshare();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  ::google::protobuf::internal::ArenaStringPtr prevhash_;
  ::google::protobuf::uint32 height_;
  ::google::protobuf::uint32 reqdiff_;
  ::google::protobuf::uint32 minshare_;
  friend void  protobuf_InitDefaults_protocol_2eproto_impl();
  friend void  protobuf_AddDesc_protocol_2eproto_impl();
  friend void protobuf_AssignDesc_protocol_2eproto();
  friend void protobuf_ShutdownFile_protocol_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<Block> Block_default_instance_;

// -------------------------------------------------------------------

class Signal : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pool.proto.Signal) */ {
 public:
  Signal();
  virtual ~Signal();

  Signal(const Signal& from);

  inline Signal& operator=(const Signal& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Signal& default_instance();

  static const Signal* internal_default_instance();

  void Swap(Signal* other);

  // implements Message ----------------------------------------------

  inline Signal* New() const { return New(NULL); }

  Signal* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Signal& from);
  void MergeFrom(const Signal& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Signal* other);
  void UnsafeMergeFrom(const Signal& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Signal_Type Type;
  static const Type NEWBLOCK =
    Signal_Type_NEWBLOCK;
  static const Type SHUTDOWN =
    Signal_Type_SHUTDOWN;
  static inline bool Type_IsValid(int value) {
    return Signal_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Signal_Type_Type_MIN;
  static const Type Type_MAX =
    Signal_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Signal_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Signal_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Signal_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Signal_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .pool.proto.Signal.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::pool::proto::Signal_Type type() const;
  void set_type(::pool::proto::Signal_Type value);

  // optional .pool.proto.Block block = 2;
  bool has_block() const;
  void clear_block();
  static const int kBlockFieldNumber = 2;
  const ::pool::proto::Block& block() const;
  ::pool::proto::Block* mutable_block();
  ::pool::proto::Block* release_block();
  void set_allocated_block(::pool::proto::Block* block);

  // @@protoc_insertion_point(class_scope:pool.proto.Signal)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_block();
  inline void clear_has_block();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::pool::proto::Block* block_;
  int type_;
  friend void  protobuf_InitDefaults_protocol_2eproto_impl();
  friend void  protobuf_AddDesc_protocol_2eproto_impl();
  friend void protobuf_AssignDesc_protocol_2eproto();
  friend void protobuf_ShutdownFile_protocol_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<Signal> Signal_default_instance_;

// -------------------------------------------------------------------

class ClientStats : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pool.proto.ClientStats) */ {
 public:
  ClientStats();
  virtual ~ClientStats();

  ClientStats(const ClientStats& from);

  inline ClientStats& operator=(const ClientStats& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientStats& default_instance();

  static const ClientStats* internal_default_instance();

  void Swap(ClientStats* other);

  // implements Message ----------------------------------------------

  inline ClientStats* New() const { return New(NULL); }

  ClientStats* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientStats& from);
  void MergeFrom(const ClientStats& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClientStats* other);
  void UnsafeMergeFrom(const ClientStats& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string addr = 1;
  bool has_addr() const;
  void clear_addr();
  static const int kAddrFieldNumber = 1;
  const ::std::string& addr() const;
  void set_addr(const ::std::string& value);
  void set_addr(const char* value);
  void set_addr(const char* value, size_t size);
  ::std::string* mutable_addr();
  ::std::string* release_addr();
  void set_allocated_addr(::std::string* addr);

  // required string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required fixed64 clientid = 3;
  bool has_clientid() const;
  void clear_clientid();
  static const int kClientidFieldNumber = 3;
  ::google::protobuf::uint64 clientid() const;
  void set_clientid(::google::protobuf::uint64 value);

  // required fixed64 instanceid = 4;
  bool has_instanceid() const;
  void clear_instanceid();
  static const int kInstanceidFieldNumber = 4;
  ::google::protobuf::uint64 instanceid() const;
  void set_instanceid(::google::protobuf::uint64 value);

  // required uint32 version = 10;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 10;
  ::google::protobuf::uint32 version() const;
  void set_version(::google::protobuf::uint32 value);

  // required float cpd = 11;
  bool has_cpd() const;
  void clear_cpd();
  static const int kCpdFieldNumber = 11;
  float cpd() const;
  void set_cpd(float value);

  // required uint32 latency = 12;
  bool has_latency() const;
  void clear_latency();
  static const int kLatencyFieldNumber = 12;
  ::google::protobuf::uint32 latency() const;
  void set_latency(::google::protobuf::uint32 value);

  // required uint32 temp = 13;
  bool has_temp() const;
  void clear_temp();
  static const int kTempFieldNumber = 13;
  ::google::protobuf::uint32 temp() const;
  void set_temp(::google::protobuf::uint32 value);

  // required uint32 errors = 14;
  bool has_errors() const;
  void clear_errors();
  static const int kErrorsFieldNumber = 14;
  ::google::protobuf::uint32 errors() const;
  void set_errors(::google::protobuf::uint32 value);

  // required uint32 ngpus = 15;
  bool has_ngpus() const;
  void clear_ngpus();
  static const int kNgpusFieldNumber = 15;
  ::google::protobuf::uint32 ngpus() const;
  void set_ngpus(::google::protobuf::uint32 value);

  // required uint32 height = 16;
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 16;
  ::google::protobuf::uint32 height() const;
  void set_height(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pool.proto.ClientStats)
 private:
  inline void set_has_addr();
  inline void clear_has_addr();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_instanceid();
  inline void clear_has_instanceid();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_cpd();
  inline void clear_has_cpd();
  inline void set_has_latency();
  inline void clear_has_latency();
  inline void set_has_temp();
  inline void clear_has_temp();
  inline void set_has_errors();
  inline void clear_has_errors();
  inline void set_has_ngpus();
  inline void clear_has_ngpus();
  inline void set_has_height();
  inline void clear_has_height();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr addr_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::uint64 clientid_;
  ::google::protobuf::uint64 instanceid_;
  ::google::protobuf::uint32 version_;
  float cpd_;
  ::google::protobuf::uint32 latency_;
  ::google::protobuf::uint32 temp_;
  ::google::protobuf::uint32 errors_;
  ::google::protobuf::uint32 ngpus_;
  ::google::protobuf::uint32 height_;
  friend void  protobuf_InitDefaults_protocol_2eproto_impl();
  friend void  protobuf_AddDesc_protocol_2eproto_impl();
  friend void protobuf_AssignDesc_protocol_2eproto();
  friend void protobuf_ShutdownFile_protocol_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<ClientStats> ClientStats_default_instance_;

// -------------------------------------------------------------------

class Share : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pool.proto.Share) */ {
 public:
  Share();
  virtual ~Share();

  Share(const Share& from);

  inline Share& operator=(const Share& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Share& default_instance();

  static const Share* internal_default_instance();

  void Swap(Share* other);

  // implements Message ----------------------------------------------

  inline Share* New() const { return New(NULL); }

  Share* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Share& from);
  void MergeFrom(const Share& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Share* other);
  void UnsafeMergeFrom(const Share& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string addr = 1;
  bool has_addr() const;
  void clear_addr();
  static const int kAddrFieldNumber = 1;
  const ::std::string& addr() const;
  void set_addr(const ::std::string& value);
  void set_addr(const char* value);
  void set_addr(const char* value, size_t size);
  ::std::string* mutable_addr();
  ::std::string* release_addr();
  void set_allocated_addr(::std::string* addr);

  // required string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required fixed64 clientid = 3;
  bool has_clientid() const;
  void clear_clientid();
  static const int kClientidFieldNumber = 3;
  ::google::protobuf::uint64 clientid() const;
  void set_clientid(::google::protobuf::uint64 value);

  // optional uint32 gpuid = 4;
  bool has_gpuid() const;
  void clear_gpuid();
  static const int kGpuidFieldNumber = 4;
  ::google::protobuf::uint32 gpuid() const;
  void set_gpuid(::google::protobuf::uint32 value);

  // required string hash = 10;
  bool has_hash() const;
  void clear_hash();
  static const int kHashFieldNumber = 10;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  void set_hash(const char* value);
  void set_hash(const char* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // required string merkle = 11;
  bool has_merkle() const;
  void clear_merkle();
  static const int kMerkleFieldNumber = 11;
  const ::std::string& merkle() const;
  void set_merkle(const ::std::string& value);
  void set_merkle(const char* value);
  void set_merkle(const char* value, size_t size);
  ::std::string* mutable_merkle();
  ::std::string* release_merkle();
  void set_allocated_merkle(::std::string* merkle);

  // required uint32 time = 12;
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 12;
  ::google::protobuf::uint32 time() const;
  void set_time(::google::protobuf::uint32 value);

  // required uint32 bits = 13;
  bool has_bits() const;
  void clear_bits();
  static const int kBitsFieldNumber = 13;
  ::google::protobuf::uint32 bits() const;
  void set_bits(::google::protobuf::uint32 value);

  // required uint32 nonce = 14;
  bool has_nonce() const;
  void clear_nonce();
  static const int kNonceFieldNumber = 14;
  ::google::protobuf::uint32 nonce() const;
  void set_nonce(::google::protobuf::uint32 value);

  // required string multi = 15;
  bool has_multi() const;
  void clear_multi();
  static const int kMultiFieldNumber = 15;
  const ::std::string& multi() const;
  void set_multi(const ::std::string& value);
  void set_multi(const char* value);
  void set_multi(const char* value, size_t size);
  ::std::string* mutable_multi();
  ::std::string* release_multi();
  void set_allocated_multi(::std::string* multi);

  // optional string blockhash = 16;
  bool has_blockhash() const;
  void clear_blockhash();
  static const int kBlockhashFieldNumber = 16;
  const ::std::string& blockhash() const;
  void set_blockhash(const ::std::string& value);
  void set_blockhash(const char* value);
  void set_blockhash(const char* value, size_t size);
  ::std::string* mutable_blockhash();
  ::std::string* release_blockhash();
  void set_allocated_blockhash(::std::string* blockhash);

  // required uint32 height = 20;
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 20;
  ::google::protobuf::uint32 height() const;
  void set_height(::google::protobuf::uint32 value);

  // required uint32 length = 21;
  bool has_length() const;
  void clear_length();
  static const int kLengthFieldNumber = 21;
  ::google::protobuf::uint32 length() const;
  void set_length(::google::protobuf::uint32 value);

  // required uint32 chaintype = 22;
  bool has_chaintype() const;
  void clear_chaintype();
  static const int kChaintypeFieldNumber = 22;
  ::google::protobuf::uint32 chaintype() const;
  void set_chaintype(::google::protobuf::uint32 value);

  // required bool isblock = 23;
  bool has_isblock() const;
  void clear_isblock();
  static const int kIsblockFieldNumber = 23;
  bool isblock() const;
  void set_isblock(bool value);

  // optional uint64 genvalue = 24;
  bool has_genvalue() const;
  void clear_genvalue();
  static const int kGenvalueFieldNumber = 24;
  ::google::protobuf::uint64 genvalue() const;
  void set_genvalue(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pool.proto.Share)
 private:
  inline void set_has_addr();
  inline void clear_has_addr();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_gpuid();
  inline void clear_has_gpuid();
  inline void set_has_hash();
  inline void clear_has_hash();
  inline void set_has_merkle();
  inline void clear_has_merkle();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_bits();
  inline void clear_has_bits();
  inline void set_has_nonce();
  inline void clear_has_nonce();
  inline void set_has_multi();
  inline void clear_has_multi();
  inline void set_has_blockhash();
  inline void clear_has_blockhash();
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_length();
  inline void clear_has_length();
  inline void set_has_chaintype();
  inline void clear_has_chaintype();
  inline void set_has_isblock();
  inline void clear_has_isblock();
  inline void set_has_genvalue();
  inline void clear_has_genvalue();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr addr_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  ::google::protobuf::internal::ArenaStringPtr merkle_;
  ::google::protobuf::internal::ArenaStringPtr multi_;
  ::google::protobuf::internal::ArenaStringPtr blockhash_;
  ::google::protobuf::uint64 clientid_;
  ::google::protobuf::uint32 gpuid_;
  ::google::protobuf::uint32 time_;
  ::google::protobuf::uint32 bits_;
  ::google::protobuf::uint32 nonce_;
  ::google::protobuf::uint32 height_;
  ::google::protobuf::uint32 length_;
  ::google::protobuf::uint32 chaintype_;
  bool isblock_;
  ::google::protobuf::uint64 genvalue_;
  friend void  protobuf_InitDefaults_protocol_2eproto_impl();
  friend void  protobuf_AddDesc_protocol_2eproto_impl();
  friend void protobuf_AssignDesc_protocol_2eproto();
  friend void protobuf_ShutdownFile_protocol_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<Share> Share_default_instance_;

// -------------------------------------------------------------------

class Request : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pool.proto.Request) */ {
 public:
  Request();
  virtual ~Request();

  Request(const Request& from);

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request& default_instance();

  static const Request* internal_default_instance();

  void Swap(Request* other);

  // implements Message ----------------------------------------------

  inline Request* New() const { return New(NULL); }

  Request* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request& from);
  void MergeFrom(const Request& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Request* other);
  void UnsafeMergeFrom(const Request& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Request_Type Type;
  static const Type NONE =
    Request_Type_NONE;
  static const Type CONNECT =
    Request_Type_CONNECT;
  static const Type GETWORK =
    Request_Type_GETWORK;
  static const Type SHARE =
    Request_Type_SHARE;
  static const Type STATS =
    Request_Type_STATS;
  static const Type PING =
    Request_Type_PING;
  static inline bool Type_IsValid(int value) {
    return Request_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Request_Type_Type_MIN;
  static const Type Type_MAX =
    Request_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Request_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Request_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Request_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Request_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .pool.proto.Request.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::pool::proto::Request_Type type() const;
  void set_type(::pool::proto::Request_Type value);

  // required uint32 reqid = 2;
  bool has_reqid() const;
  void clear_reqid();
  static const int kReqidFieldNumber = 2;
  ::google::protobuf::uint32 reqid() const;
  void set_reqid(::google::protobuf::uint32 value);

  // optional uint32 version = 10;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 10;
  ::google::protobuf::uint32 version() const;
  void set_version(::google::protobuf::uint32 value);

  // optional uint32 height = 11;
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 11;
  ::google::protobuf::uint32 height() const;
  void set_height(::google::protobuf::uint32 value);

  // optional bytes reqnonce = 12;
  bool has_reqnonce() const;
  void clear_reqnonce();
  static const int kReqnonceFieldNumber = 12;
  const ::std::string& reqnonce() const;
  void set_reqnonce(const ::std::string& value);
  void set_reqnonce(const char* value);
  void set_reqnonce(const void* value, size_t size);
  ::std::string* mutable_reqnonce();
  ::std::string* release_reqnonce();
  void set_allocated_reqnonce(::std::string* reqnonce);

  // optional .pool.proto.Share share = 20;
  bool has_share() const;
  void clear_share();
  static const int kShareFieldNumber = 20;
  const ::pool::proto::Share& share() const;
  ::pool::proto::Share* mutable_share();
  ::pool::proto::Share* release_share();
  void set_allocated_share(::pool::proto::Share* share);

  // optional .pool.proto.ClientStats stats = 21;
  bool has_stats() const;
  void clear_stats();
  static const int kStatsFieldNumber = 21;
  const ::pool::proto::ClientStats& stats() const;
  ::pool::proto::ClientStats* mutable_stats();
  ::pool::proto::ClientStats* release_stats();
  void set_allocated_stats(::pool::proto::ClientStats* stats);

  // @@protoc_insertion_point(class_scope:pool.proto.Request)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_reqid();
  inline void clear_has_reqid();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_reqnonce();
  inline void clear_has_reqnonce();
  inline void set_has_share();
  inline void clear_has_share();
  inline void set_has_stats();
  inline void clear_has_stats();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr reqnonce_;
  ::pool::proto::Share* share_;
  ::pool::proto::ClientStats* stats_;
  int type_;
  ::google::protobuf::uint32 reqid_;
  ::google::protobuf::uint32 version_;
  ::google::protobuf::uint32 height_;
  friend void  protobuf_InitDefaults_protocol_2eproto_impl();
  friend void  protobuf_AddDesc_protocol_2eproto_impl();
  friend void protobuf_AssignDesc_protocol_2eproto();
  friend void protobuf_ShutdownFile_protocol_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<Request> Request_default_instance_;

// -------------------------------------------------------------------

class ServerInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pool.proto.ServerInfo) */ {
 public:
  ServerInfo();
  virtual ~ServerInfo();

  ServerInfo(const ServerInfo& from);

  inline ServerInfo& operator=(const ServerInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerInfo& default_instance();

  static const ServerInfo* internal_default_instance();

  void Swap(ServerInfo* other);

  // implements Message ----------------------------------------------

  inline ServerInfo* New() const { return New(NULL); }

  ServerInfo* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerInfo& from);
  void MergeFrom(const ServerInfo& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ServerInfo* other);
  void UnsafeMergeFrom(const ServerInfo& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string host = 1;
  bool has_host() const;
  void clear_host();
  static const int kHostFieldNumber = 1;
  const ::std::string& host() const;
  void set_host(const ::std::string& value);
  void set_host(const char* value);
  void set_host(const char* value, size_t size);
  ::std::string* mutable_host();
  ::std::string* release_host();
  void set_allocated_host(::std::string* host);

  // required uint32 router = 2;
  bool has_router() const;
  void clear_router();
  static const int kRouterFieldNumber = 2;
  ::google::protobuf::uint32 router() const;
  void set_router(::google::protobuf::uint32 value);

  // required uint32 pub = 3;
  bool has_pub() const;
  void clear_pub();
  static const int kPubFieldNumber = 3;
  ::google::protobuf::uint32 pub() const;
  void set_pub(::google::protobuf::uint32 value);

  // required uint32 target = 4;
  bool has_target() const;
  void clear_target();
  static const int kTargetFieldNumber = 4;
  ::google::protobuf::uint32 target() const;
  void set_target(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pool.proto.ServerInfo)
 private:
  inline void set_has_host();
  inline void clear_has_host();
  inline void set_has_router();
  inline void clear_has_router();
  inline void set_has_pub();
  inline void clear_has_pub();
  inline void set_has_target();
  inline void clear_has_target();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr host_;
  ::google::protobuf::uint32 router_;
  ::google::protobuf::uint32 pub_;
  ::google::protobuf::uint32 target_;
  friend void  protobuf_InitDefaults_protocol_2eproto_impl();
  friend void  protobuf_AddDesc_protocol_2eproto_impl();
  friend void protobuf_AssignDesc_protocol_2eproto();
  friend void protobuf_ShutdownFile_protocol_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<ServerInfo> ServerInfo_default_instance_;

// -------------------------------------------------------------------

class Work : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pool.proto.Work) */ {
 public:
  Work();
  virtual ~Work();

  Work(const Work& from);

  inline Work& operator=(const Work& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Work& default_instance();

  static const Work* internal_default_instance();

  void Swap(Work* other);

  // implements Message ----------------------------------------------

  inline Work* New() const { return New(NULL); }

  Work* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Work& from);
  void MergeFrom(const Work& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Work* other);
  void UnsafeMergeFrom(const Work& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 height = 1;
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 1;
  ::google::protobuf::uint32 height() const;
  void set_height(::google::protobuf::uint32 value);

  // required string merkle = 2;
  bool has_merkle() const;
  void clear_merkle();
  static const int kMerkleFieldNumber = 2;
  const ::std::string& merkle() const;
  void set_merkle(const ::std::string& value);
  void set_merkle(const char* value);
  void set_merkle(const char* value, size_t size);
  ::std::string* mutable_merkle();
  ::std::string* release_merkle();
  void set_allocated_merkle(::std::string* merkle);

  // required uint32 time = 3;
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 3;
  ::google::protobuf::uint32 time() const;
  void set_time(::google::protobuf::uint32 value);

  // required uint32 bits = 4;
  bool has_bits() const;
  void clear_bits();
  static const int kBitsFieldNumber = 4;
  ::google::protobuf::uint32 bits() const;
  void set_bits(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pool.proto.Work)
 private:
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_merkle();
  inline void clear_has_merkle();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_bits();
  inline void clear_has_bits();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr merkle_;
  ::google::protobuf::uint32 height_;
  ::google::protobuf::uint32 time_;
  ::google::protobuf::uint32 bits_;
  friend void  protobuf_InitDefaults_protocol_2eproto_impl();
  friend void  protobuf_AddDesc_protocol_2eproto_impl();
  friend void protobuf_AssignDesc_protocol_2eproto();
  friend void protobuf_ShutdownFile_protocol_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<Work> Work_default_instance_;

// -------------------------------------------------------------------

class Reply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pool.proto.Reply) */ {
 public:
  Reply();
  virtual ~Reply();

  Reply(const Reply& from);

  inline Reply& operator=(const Reply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Reply& default_instance();

  static const Reply* internal_default_instance();

  void Swap(Reply* other);

  // implements Message ----------------------------------------------

  inline Reply* New() const { return New(NULL); }

  Reply* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Reply& from);
  void MergeFrom(const Reply& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Reply* other);
  void UnsafeMergeFrom(const Reply& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Reply_ErrType ErrType;
  static const ErrType NONE =
    Reply_ErrType_NONE;
  static const ErrType VERSION =
    Reply_ErrType_VERSION;
  static const ErrType HEIGHT =
    Reply_ErrType_HEIGHT;
  static const ErrType REQNONCE =
    Reply_ErrType_REQNONCE;
  static const ErrType STALE =
    Reply_ErrType_STALE;
  static const ErrType INVALID =
    Reply_ErrType_INVALID;
  static const ErrType DUPLICATE =
    Reply_ErrType_DUPLICATE;
  static inline bool ErrType_IsValid(int value) {
    return Reply_ErrType_IsValid(value);
  }
  static const ErrType ErrType_MIN =
    Reply_ErrType_ErrType_MIN;
  static const ErrType ErrType_MAX =
    Reply_ErrType_ErrType_MAX;
  static const int ErrType_ARRAYSIZE =
    Reply_ErrType_ErrType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ErrType_descriptor() {
    return Reply_ErrType_descriptor();
  }
  static inline const ::std::string& ErrType_Name(ErrType value) {
    return Reply_ErrType_Name(value);
  }
  static inline bool ErrType_Parse(const ::std::string& name,
      ErrType* value) {
    return Reply_ErrType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .pool.proto.Request.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::pool::proto::Request_Type type() const;
  void set_type(::pool::proto::Request_Type value);

  // required uint32 reqid = 2;
  bool has_reqid() const;
  void clear_reqid();
  static const int kReqidFieldNumber = 2;
  ::google::protobuf::uint32 reqid() const;
  void set_reqid(::google::protobuf::uint32 value);

  // required .pool.proto.Reply.ErrType error = 10;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 10;
  ::pool::proto::Reply_ErrType error() const;
  void set_error(::pool::proto::Reply_ErrType value);

  // optional string errstr = 11;
  bool has_errstr() const;
  void clear_errstr();
  static const int kErrstrFieldNumber = 11;
  const ::std::string& errstr() const;
  void set_errstr(const ::std::string& value);
  void set_errstr(const char* value);
  void set_errstr(const char* value, size_t size);
  ::std::string* mutable_errstr();
  ::std::string* release_errstr();
  void set_allocated_errstr(::std::string* errstr);

  // optional .pool.proto.ServerInfo sinfo = 20;
  bool has_sinfo() const;
  void clear_sinfo();
  static const int kSinfoFieldNumber = 20;
  const ::pool::proto::ServerInfo& sinfo() const;
  ::pool::proto::ServerInfo* mutable_sinfo();
  ::pool::proto::ServerInfo* release_sinfo();
  void set_allocated_sinfo(::pool::proto::ServerInfo* sinfo);

  // optional .pool.proto.Work work = 21;
  bool has_work() const;
  void clear_work();
  static const int kWorkFieldNumber = 21;
  const ::pool::proto::Work& work() const;
  ::pool::proto::Work* mutable_work();
  ::pool::proto::Work* release_work();
  void set_allocated_work(::pool::proto::Work* work);

  // optional .pool.proto.Block block = 22;
  bool has_block() const;
  void clear_block();
  static const int kBlockFieldNumber = 22;
  const ::pool::proto::Block& block() const;
  ::pool::proto::Block* mutable_block();
  ::pool::proto::Block* release_block();
  void set_allocated_block(::pool::proto::Block* block);

  // @@protoc_insertion_point(class_scope:pool.proto.Reply)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_reqid();
  inline void clear_has_reqid();
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_errstr();
  inline void clear_has_errstr();
  inline void set_has_sinfo();
  inline void clear_has_sinfo();
  inline void set_has_work();
  inline void clear_has_work();
  inline void set_has_block();
  inline void clear_has_block();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr errstr_;
  ::pool::proto::ServerInfo* sinfo_;
  ::pool::proto::Work* work_;
  ::pool::proto::Block* block_;
  int type_;
  ::google::protobuf::uint32 reqid_;
  int error_;
  friend void  protobuf_InitDefaults_protocol_2eproto_impl();
  friend void  protobuf_AddDesc_protocol_2eproto_impl();
  friend void protobuf_AssignDesc_protocol_2eproto();
  friend void protobuf_ShutdownFile_protocol_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<Reply> Reply_default_instance_;

// -------------------------------------------------------------------

class ReqStats : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pool.proto.ReqStats) */ {
 public:
  ReqStats();
  virtual ~ReqStats();

  ReqStats(const ReqStats& from);

  inline ReqStats& operator=(const ReqStats& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqStats& default_instance();

  static const ReqStats* internal_default_instance();

  void Swap(ReqStats* other);

  // implements Message ----------------------------------------------

  inline ReqStats* New() const { return New(NULL); }

  ReqStats* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqStats& from);
  void MergeFrom(const ReqStats& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ReqStats* other);
  void UnsafeMergeFrom(const ReqStats& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pool.proto.Request.Type reqtype = 1;
  bool has_reqtype() const;
  void clear_reqtype();
  static const int kReqtypeFieldNumber = 1;
  ::pool::proto::Request_Type reqtype() const;
  void set_reqtype(::pool::proto::Request_Type value);

  // required .pool.proto.Reply.ErrType errtype = 2;
  bool has_errtype() const;
  void clear_errtype();
  static const int kErrtypeFieldNumber = 2;
  ::pool::proto::Reply_ErrType errtype() const;
  void set_errtype(::pool::proto::Reply_ErrType value);

  // required uint32 count = 3;
  bool has_count() const;
  void clear_count();
  static const int kCountFieldNumber = 3;
  ::google::protobuf::uint32 count() const;
  void set_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pool.proto.ReqStats)
 private:
  inline void set_has_reqtype();
  inline void clear_has_reqtype();
  inline void set_has_errtype();
  inline void clear_has_errtype();
  inline void set_has_count();
  inline void clear_has_count();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int reqtype_;
  int errtype_;
  ::google::protobuf::uint32 count_;
  friend void  protobuf_InitDefaults_protocol_2eproto_impl();
  friend void  protobuf_AddDesc_protocol_2eproto_impl();
  friend void protobuf_AssignDesc_protocol_2eproto();
  friend void protobuf_ShutdownFile_protocol_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<ReqStats> ReqStats_default_instance_;

// -------------------------------------------------------------------

class ServerStats : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pool.proto.ServerStats) */ {
 public:
  ServerStats();
  virtual ~ServerStats();

  ServerStats(const ServerStats& from);

  inline ServerStats& operator=(const ServerStats& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerStats& default_instance();

  static const ServerStats* internal_default_instance();

  void Swap(ServerStats* other);

  // implements Message ----------------------------------------------

  inline ServerStats* New() const { return New(NULL); }

  ServerStats* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerStats& from);
  void MergeFrom(const ServerStats& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ServerStats* other);
  void UnsafeMergeFrom(const ServerStats& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required uint32 thread = 2;
  bool has_thread() const;
  void clear_thread();
  static const int kThreadFieldNumber = 2;
  ::google::protobuf::uint32 thread() const;
  void set_thread(::google::protobuf::uint32 value);

  // required uint32 workers = 10;
  bool has_workers() const;
  void clear_workers();
  static const int kWorkersFieldNumber = 10;
  ::google::protobuf::uint32 workers() const;
  void set_workers(::google::protobuf::uint32 value);

  // required uint32 latency = 11;
  bool has_latency() const;
  void clear_latency();
  static const int kLatencyFieldNumber = 11;
  ::google::protobuf::uint32 latency() const;
  void set_latency(::google::protobuf::uint32 value);

  // required float cpd = 12;
  bool has_cpd() const;
  void clear_cpd();
  static const int kCpdFieldNumber = 12;
  float cpd() const;
  void set_cpd(float value);

  // repeated .pool.proto.ReqStats reqstats = 20;
  int reqstats_size() const;
  void clear_reqstats();
  static const int kReqstatsFieldNumber = 20;
  const ::pool::proto::ReqStats& reqstats(int index) const;
  ::pool::proto::ReqStats* mutable_reqstats(int index);
  ::pool::proto::ReqStats* add_reqstats();
  ::google::protobuf::RepeatedPtrField< ::pool::proto::ReqStats >*
      mutable_reqstats();
  const ::google::protobuf::RepeatedPtrField< ::pool::proto::ReqStats >&
      reqstats() const;

  // @@protoc_insertion_point(class_scope:pool.proto.ServerStats)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_thread();
  inline void clear_has_thread();
  inline void set_has_workers();
  inline void clear_has_workers();
  inline void set_has_latency();
  inline void clear_has_latency();
  inline void set_has_cpd();
  inline void clear_has_cpd();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::pool::proto::ReqStats > reqstats_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::uint32 thread_;
  ::google::protobuf::uint32 workers_;
  ::google::protobuf::uint32 latency_;
  float cpd_;
  friend void  protobuf_InitDefaults_protocol_2eproto_impl();
  friend void  protobuf_AddDesc_protocol_2eproto_impl();
  friend void protobuf_AssignDesc_protocol_2eproto();
  friend void protobuf_ShutdownFile_protocol_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<ServerStats> ServerStats_default_instance_;

// -------------------------------------------------------------------

class Data : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pool.proto.Data) */ {
 public:
  Data();
  virtual ~Data();

  Data(const Data& from);

  inline Data& operator=(const Data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Data& default_instance();

  static const Data* internal_default_instance();

  void Swap(Data* other);

  // implements Message ----------------------------------------------

  inline Data* New() const { return New(NULL); }

  Data* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Data& from);
  void MergeFrom(const Data& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Data* other);
  void UnsafeMergeFrom(const Data& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pool.proto.Share share = 1;
  bool has_share() const;
  void clear_share();
  static const int kShareFieldNumber = 1;
  const ::pool::proto::Share& share() const;
  ::pool::proto::Share* mutable_share();
  ::pool::proto::Share* release_share();
  void set_allocated_share(::pool::proto::Share* share);

  // optional .pool.proto.ClientStats clientstats = 2;
  bool has_clientstats() const;
  void clear_clientstats();
  static const int kClientstatsFieldNumber = 2;
  const ::pool::proto::ClientStats& clientstats() const;
  ::pool::proto::ClientStats* mutable_clientstats();
  ::pool::proto::ClientStats* release_clientstats();
  void set_allocated_clientstats(::pool::proto::ClientStats* clientstats);

  // optional .pool.proto.ServerStats serverstats = 3;
  bool has_serverstats() const;
  void clear_serverstats();
  static const int kServerstatsFieldNumber = 3;
  const ::pool::proto::ServerStats& serverstats() const;
  ::pool::proto::ServerStats* mutable_serverstats();
  ::pool::proto::ServerStats* release_serverstats();
  void set_allocated_serverstats(::pool::proto::ServerStats* serverstats);

  // @@protoc_insertion_point(class_scope:pool.proto.Data)
 private:
  inline void set_has_share();
  inline void clear_has_share();
  inline void set_has_clientstats();
  inline void clear_has_clientstats();
  inline void set_has_serverstats();
  inline void clear_has_serverstats();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::pool::proto::Share* share_;
  ::pool::proto::ClientStats* clientstats_;
  ::pool::proto::ServerStats* serverstats_;
  friend void  protobuf_InitDefaults_protocol_2eproto_impl();
  friend void  protobuf_AddDesc_protocol_2eproto_impl();
  friend void protobuf_AssignDesc_protocol_2eproto();
  friend void protobuf_ShutdownFile_protocol_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<Data> Data_default_instance_;

// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Block

// required uint32 height = 1;
inline bool Block::has_height() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Block::set_has_height() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Block::clear_has_height() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Block::clear_height() {
  height_ = 0u;
  clear_has_height();
}
inline ::google::protobuf::uint32 Block::height() const {
  // @@protoc_insertion_point(field_get:pool.proto.Block.height)
  return height_;
}
inline void Block::set_height(::google::protobuf::uint32 value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.Block.height)
}

// required string hash = 2;
inline bool Block::has_hash() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Block::set_has_hash() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Block::clear_has_hash() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Block::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hash();
}
inline const ::std::string& Block::hash() const {
  // @@protoc_insertion_point(field_get:pool.proto.Block.hash)
  return hash_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Block::set_hash(const ::std::string& value) {
  set_has_hash();
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pool.proto.Block.hash)
}
inline void Block::set_hash(const char* value) {
  set_has_hash();
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pool.proto.Block.hash)
}
inline void Block::set_hash(const char* value, size_t size) {
  set_has_hash();
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pool.proto.Block.hash)
}
inline ::std::string* Block::mutable_hash() {
  set_has_hash();
  // @@protoc_insertion_point(field_mutable:pool.proto.Block.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Block::release_hash() {
  // @@protoc_insertion_point(field_release:pool.proto.Block.hash)
  clear_has_hash();
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Block::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    set_has_hash();
  } else {
    clear_has_hash();
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:pool.proto.Block.hash)
}

// required string prevhash = 3;
inline bool Block::has_prevhash() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Block::set_has_prevhash() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Block::clear_has_prevhash() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Block::clear_prevhash() {
  prevhash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_prevhash();
}
inline const ::std::string& Block::prevhash() const {
  // @@protoc_insertion_point(field_get:pool.proto.Block.prevhash)
  return prevhash_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Block::set_prevhash(const ::std::string& value) {
  set_has_prevhash();
  prevhash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pool.proto.Block.prevhash)
}
inline void Block::set_prevhash(const char* value) {
  set_has_prevhash();
  prevhash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pool.proto.Block.prevhash)
}
inline void Block::set_prevhash(const char* value, size_t size) {
  set_has_prevhash();
  prevhash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pool.proto.Block.prevhash)
}
inline ::std::string* Block::mutable_prevhash() {
  set_has_prevhash();
  // @@protoc_insertion_point(field_mutable:pool.proto.Block.prevhash)
  return prevhash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Block::release_prevhash() {
  // @@protoc_insertion_point(field_release:pool.proto.Block.prevhash)
  clear_has_prevhash();
  return prevhash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Block::set_allocated_prevhash(::std::string* prevhash) {
  if (prevhash != NULL) {
    set_has_prevhash();
  } else {
    clear_has_prevhash();
  }
  prevhash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), prevhash);
  // @@protoc_insertion_point(field_set_allocated:pool.proto.Block.prevhash)
}

// required uint32 reqdiff = 4;
inline bool Block::has_reqdiff() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Block::set_has_reqdiff() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Block::clear_has_reqdiff() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Block::clear_reqdiff() {
  reqdiff_ = 0u;
  clear_has_reqdiff();
}
inline ::google::protobuf::uint32 Block::reqdiff() const {
  // @@protoc_insertion_point(field_get:pool.proto.Block.reqdiff)
  return reqdiff_;
}
inline void Block::set_reqdiff(::google::protobuf::uint32 value) {
  set_has_reqdiff();
  reqdiff_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.Block.reqdiff)
}

// required uint32 minshare = 5;
inline bool Block::has_minshare() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Block::set_has_minshare() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Block::clear_has_minshare() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Block::clear_minshare() {
  minshare_ = 0u;
  clear_has_minshare();
}
inline ::google::protobuf::uint32 Block::minshare() const {
  // @@protoc_insertion_point(field_get:pool.proto.Block.minshare)
  return minshare_;
}
inline void Block::set_minshare(::google::protobuf::uint32 value) {
  set_has_minshare();
  minshare_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.Block.minshare)
}

inline const Block* Block::internal_default_instance() {
  return &Block_default_instance_.get();
}
// -------------------------------------------------------------------

// Signal

// required .pool.proto.Signal.Type type = 1;
inline bool Signal::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Signal::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Signal::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Signal::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::pool::proto::Signal_Type Signal::type() const {
  // @@protoc_insertion_point(field_get:pool.proto.Signal.type)
  return static_cast< ::pool::proto::Signal_Type >(type_);
}
inline void Signal::set_type(::pool::proto::Signal_Type value) {
  assert(::pool::proto::Signal_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.Signal.type)
}

// optional .pool.proto.Block block = 2;
inline bool Signal::has_block() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Signal::set_has_block() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Signal::clear_has_block() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Signal::clear_block() {
  if (block_ != NULL) block_->::pool::proto::Block::Clear();
  clear_has_block();
}
inline const ::pool::proto::Block& Signal::block() const {
  // @@protoc_insertion_point(field_get:pool.proto.Signal.block)
  return block_ != NULL ? *block_
                         : *::pool::proto::Block::internal_default_instance();
}
inline ::pool::proto::Block* Signal::mutable_block() {
  set_has_block();
  if (block_ == NULL) {
    block_ = new ::pool::proto::Block;
  }
  // @@protoc_insertion_point(field_mutable:pool.proto.Signal.block)
  return block_;
}
inline ::pool::proto::Block* Signal::release_block() {
  // @@protoc_insertion_point(field_release:pool.proto.Signal.block)
  clear_has_block();
  ::pool::proto::Block* temp = block_;
  block_ = NULL;
  return temp;
}
inline void Signal::set_allocated_block(::pool::proto::Block* block) {
  delete block_;
  block_ = block;
  if (block) {
    set_has_block();
  } else {
    clear_has_block();
  }
  // @@protoc_insertion_point(field_set_allocated:pool.proto.Signal.block)
}

inline const Signal* Signal::internal_default_instance() {
  return &Signal_default_instance_.get();
}
// -------------------------------------------------------------------

// ClientStats

// required string addr = 1;
inline bool ClientStats::has_addr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientStats::set_has_addr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientStats::clear_has_addr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientStats::clear_addr() {
  addr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_addr();
}
inline const ::std::string& ClientStats::addr() const {
  // @@protoc_insertion_point(field_get:pool.proto.ClientStats.addr)
  return addr_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ClientStats::set_addr(const ::std::string& value) {
  set_has_addr();
  addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pool.proto.ClientStats.addr)
}
inline void ClientStats::set_addr(const char* value) {
  set_has_addr();
  addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pool.proto.ClientStats.addr)
}
inline void ClientStats::set_addr(const char* value, size_t size) {
  set_has_addr();
  addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pool.proto.ClientStats.addr)
}
inline ::std::string* ClientStats::mutable_addr() {
  set_has_addr();
  // @@protoc_insertion_point(field_mutable:pool.proto.ClientStats.addr)
  return addr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ClientStats::release_addr() {
  // @@protoc_insertion_point(field_release:pool.proto.ClientStats.addr)
  clear_has_addr();
  return addr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ClientStats::set_allocated_addr(::std::string* addr) {
  if (addr != NULL) {
    set_has_addr();
  } else {
    clear_has_addr();
  }
  addr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), addr);
  // @@protoc_insertion_point(field_set_allocated:pool.proto.ClientStats.addr)
}

// required string name = 2;
inline bool ClientStats::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientStats::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientStats::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientStats::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& ClientStats::name() const {
  // @@protoc_insertion_point(field_get:pool.proto.ClientStats.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ClientStats::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pool.proto.ClientStats.name)
}
inline void ClientStats::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pool.proto.ClientStats.name)
}
inline void ClientStats::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pool.proto.ClientStats.name)
}
inline ::std::string* ClientStats::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:pool.proto.ClientStats.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ClientStats::release_name() {
  // @@protoc_insertion_point(field_release:pool.proto.ClientStats.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ClientStats::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:pool.proto.ClientStats.name)
}

// required fixed64 clientid = 3;
inline bool ClientStats::has_clientid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientStats::set_has_clientid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientStats::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientStats::clear_clientid() {
  clientid_ = GOOGLE_ULONGLONG(0);
  clear_has_clientid();
}
inline ::google::protobuf::uint64 ClientStats::clientid() const {
  // @@protoc_insertion_point(field_get:pool.proto.ClientStats.clientid)
  return clientid_;
}
inline void ClientStats::set_clientid(::google::protobuf::uint64 value) {
  set_has_clientid();
  clientid_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.ClientStats.clientid)
}

// required fixed64 instanceid = 4;
inline bool ClientStats::has_instanceid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClientStats::set_has_instanceid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClientStats::clear_has_instanceid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClientStats::clear_instanceid() {
  instanceid_ = GOOGLE_ULONGLONG(0);
  clear_has_instanceid();
}
inline ::google::protobuf::uint64 ClientStats::instanceid() const {
  // @@protoc_insertion_point(field_get:pool.proto.ClientStats.instanceid)
  return instanceid_;
}
inline void ClientStats::set_instanceid(::google::protobuf::uint64 value) {
  set_has_instanceid();
  instanceid_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.ClientStats.instanceid)
}

// required uint32 version = 10;
inline bool ClientStats::has_version() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClientStats::set_has_version() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ClientStats::clear_has_version() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ClientStats::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 ClientStats::version() const {
  // @@protoc_insertion_point(field_get:pool.proto.ClientStats.version)
  return version_;
}
inline void ClientStats::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.ClientStats.version)
}

// required float cpd = 11;
inline bool ClientStats::has_cpd() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ClientStats::set_has_cpd() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ClientStats::clear_has_cpd() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ClientStats::clear_cpd() {
  cpd_ = 0;
  clear_has_cpd();
}
inline float ClientStats::cpd() const {
  // @@protoc_insertion_point(field_get:pool.proto.ClientStats.cpd)
  return cpd_;
}
inline void ClientStats::set_cpd(float value) {
  set_has_cpd();
  cpd_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.ClientStats.cpd)
}

// required uint32 latency = 12;
inline bool ClientStats::has_latency() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ClientStats::set_has_latency() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ClientStats::clear_has_latency() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ClientStats::clear_latency() {
  latency_ = 0u;
  clear_has_latency();
}
inline ::google::protobuf::uint32 ClientStats::latency() const {
  // @@protoc_insertion_point(field_get:pool.proto.ClientStats.latency)
  return latency_;
}
inline void ClientStats::set_latency(::google::protobuf::uint32 value) {
  set_has_latency();
  latency_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.ClientStats.latency)
}

// required uint32 temp = 13;
inline bool ClientStats::has_temp() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ClientStats::set_has_temp() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ClientStats::clear_has_temp() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ClientStats::clear_temp() {
  temp_ = 0u;
  clear_has_temp();
}
inline ::google::protobuf::uint32 ClientStats::temp() const {
  // @@protoc_insertion_point(field_get:pool.proto.ClientStats.temp)
  return temp_;
}
inline void ClientStats::set_temp(::google::protobuf::uint32 value) {
  set_has_temp();
  temp_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.ClientStats.temp)
}

// required uint32 errors = 14;
inline bool ClientStats::has_errors() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ClientStats::set_has_errors() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ClientStats::clear_has_errors() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ClientStats::clear_errors() {
  errors_ = 0u;
  clear_has_errors();
}
inline ::google::protobuf::uint32 ClientStats::errors() const {
  // @@protoc_insertion_point(field_get:pool.proto.ClientStats.errors)
  return errors_;
}
inline void ClientStats::set_errors(::google::protobuf::uint32 value) {
  set_has_errors();
  errors_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.ClientStats.errors)
}

// required uint32 ngpus = 15;
inline bool ClientStats::has_ngpus() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ClientStats::set_has_ngpus() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ClientStats::clear_has_ngpus() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ClientStats::clear_ngpus() {
  ngpus_ = 0u;
  clear_has_ngpus();
}
inline ::google::protobuf::uint32 ClientStats::ngpus() const {
  // @@protoc_insertion_point(field_get:pool.proto.ClientStats.ngpus)
  return ngpus_;
}
inline void ClientStats::set_ngpus(::google::protobuf::uint32 value) {
  set_has_ngpus();
  ngpus_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.ClientStats.ngpus)
}

// required uint32 height = 16;
inline bool ClientStats::has_height() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ClientStats::set_has_height() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ClientStats::clear_has_height() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ClientStats::clear_height() {
  height_ = 0u;
  clear_has_height();
}
inline ::google::protobuf::uint32 ClientStats::height() const {
  // @@protoc_insertion_point(field_get:pool.proto.ClientStats.height)
  return height_;
}
inline void ClientStats::set_height(::google::protobuf::uint32 value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.ClientStats.height)
}

inline const ClientStats* ClientStats::internal_default_instance() {
  return &ClientStats_default_instance_.get();
}
// -------------------------------------------------------------------

// Share

// required string addr = 1;
inline bool Share::has_addr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Share::set_has_addr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Share::clear_has_addr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Share::clear_addr() {
  addr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_addr();
}
inline const ::std::string& Share::addr() const {
  // @@protoc_insertion_point(field_get:pool.proto.Share.addr)
  return addr_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Share::set_addr(const ::std::string& value) {
  set_has_addr();
  addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pool.proto.Share.addr)
}
inline void Share::set_addr(const char* value) {
  set_has_addr();
  addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pool.proto.Share.addr)
}
inline void Share::set_addr(const char* value, size_t size) {
  set_has_addr();
  addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pool.proto.Share.addr)
}
inline ::std::string* Share::mutable_addr() {
  set_has_addr();
  // @@protoc_insertion_point(field_mutable:pool.proto.Share.addr)
  return addr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Share::release_addr() {
  // @@protoc_insertion_point(field_release:pool.proto.Share.addr)
  clear_has_addr();
  return addr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Share::set_allocated_addr(::std::string* addr) {
  if (addr != NULL) {
    set_has_addr();
  } else {
    clear_has_addr();
  }
  addr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), addr);
  // @@protoc_insertion_point(field_set_allocated:pool.proto.Share.addr)
}

// required string name = 2;
inline bool Share::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Share::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Share::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Share::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Share::name() const {
  // @@protoc_insertion_point(field_get:pool.proto.Share.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Share::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pool.proto.Share.name)
}
inline void Share::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pool.proto.Share.name)
}
inline void Share::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pool.proto.Share.name)
}
inline ::std::string* Share::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:pool.proto.Share.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Share::release_name() {
  // @@protoc_insertion_point(field_release:pool.proto.Share.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Share::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:pool.proto.Share.name)
}

// required fixed64 clientid = 3;
inline bool Share::has_clientid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Share::set_has_clientid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Share::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Share::clear_clientid() {
  clientid_ = GOOGLE_ULONGLONG(0);
  clear_has_clientid();
}
inline ::google::protobuf::uint64 Share::clientid() const {
  // @@protoc_insertion_point(field_get:pool.proto.Share.clientid)
  return clientid_;
}
inline void Share::set_clientid(::google::protobuf::uint64 value) {
  set_has_clientid();
  clientid_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.Share.clientid)
}

// optional uint32 gpuid = 4;
inline bool Share::has_gpuid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Share::set_has_gpuid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Share::clear_has_gpuid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Share::clear_gpuid() {
  gpuid_ = 0u;
  clear_has_gpuid();
}
inline ::google::protobuf::uint32 Share::gpuid() const {
  // @@protoc_insertion_point(field_get:pool.proto.Share.gpuid)
  return gpuid_;
}
inline void Share::set_gpuid(::google::protobuf::uint32 value) {
  set_has_gpuid();
  gpuid_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.Share.gpuid)
}

// required string hash = 10;
inline bool Share::has_hash() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Share::set_has_hash() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Share::clear_has_hash() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Share::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hash();
}
inline const ::std::string& Share::hash() const {
  // @@protoc_insertion_point(field_get:pool.proto.Share.hash)
  return hash_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Share::set_hash(const ::std::string& value) {
  set_has_hash();
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pool.proto.Share.hash)
}
inline void Share::set_hash(const char* value) {
  set_has_hash();
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pool.proto.Share.hash)
}
inline void Share::set_hash(const char* value, size_t size) {
  set_has_hash();
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pool.proto.Share.hash)
}
inline ::std::string* Share::mutable_hash() {
  set_has_hash();
  // @@protoc_insertion_point(field_mutable:pool.proto.Share.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Share::release_hash() {
  // @@protoc_insertion_point(field_release:pool.proto.Share.hash)
  clear_has_hash();
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Share::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    set_has_hash();
  } else {
    clear_has_hash();
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:pool.proto.Share.hash)
}

// required string merkle = 11;
inline bool Share::has_merkle() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Share::set_has_merkle() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Share::clear_has_merkle() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Share::clear_merkle() {
  merkle_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_merkle();
}
inline const ::std::string& Share::merkle() const {
  // @@protoc_insertion_point(field_get:pool.proto.Share.merkle)
  return merkle_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Share::set_merkle(const ::std::string& value) {
  set_has_merkle();
  merkle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pool.proto.Share.merkle)
}
inline void Share::set_merkle(const char* value) {
  set_has_merkle();
  merkle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pool.proto.Share.merkle)
}
inline void Share::set_merkle(const char* value, size_t size) {
  set_has_merkle();
  merkle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pool.proto.Share.merkle)
}
inline ::std::string* Share::mutable_merkle() {
  set_has_merkle();
  // @@protoc_insertion_point(field_mutable:pool.proto.Share.merkle)
  return merkle_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Share::release_merkle() {
  // @@protoc_insertion_point(field_release:pool.proto.Share.merkle)
  clear_has_merkle();
  return merkle_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Share::set_allocated_merkle(::std::string* merkle) {
  if (merkle != NULL) {
    set_has_merkle();
  } else {
    clear_has_merkle();
  }
  merkle_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), merkle);
  // @@protoc_insertion_point(field_set_allocated:pool.proto.Share.merkle)
}

// required uint32 time = 12;
inline bool Share::has_time() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Share::set_has_time() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Share::clear_has_time() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Share::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 Share::time() const {
  // @@protoc_insertion_point(field_get:pool.proto.Share.time)
  return time_;
}
inline void Share::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.Share.time)
}

// required uint32 bits = 13;
inline bool Share::has_bits() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Share::set_has_bits() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Share::clear_has_bits() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Share::clear_bits() {
  bits_ = 0u;
  clear_has_bits();
}
inline ::google::protobuf::uint32 Share::bits() const {
  // @@protoc_insertion_point(field_get:pool.proto.Share.bits)
  return bits_;
}
inline void Share::set_bits(::google::protobuf::uint32 value) {
  set_has_bits();
  bits_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.Share.bits)
}

// required uint32 nonce = 14;
inline bool Share::has_nonce() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Share::set_has_nonce() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Share::clear_has_nonce() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Share::clear_nonce() {
  nonce_ = 0u;
  clear_has_nonce();
}
inline ::google::protobuf::uint32 Share::nonce() const {
  // @@protoc_insertion_point(field_get:pool.proto.Share.nonce)
  return nonce_;
}
inline void Share::set_nonce(::google::protobuf::uint32 value) {
  set_has_nonce();
  nonce_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.Share.nonce)
}

// required string multi = 15;
inline bool Share::has_multi() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Share::set_has_multi() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Share::clear_has_multi() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Share::clear_multi() {
  multi_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_multi();
}
inline const ::std::string& Share::multi() const {
  // @@protoc_insertion_point(field_get:pool.proto.Share.multi)
  return multi_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Share::set_multi(const ::std::string& value) {
  set_has_multi();
  multi_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pool.proto.Share.multi)
}
inline void Share::set_multi(const char* value) {
  set_has_multi();
  multi_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pool.proto.Share.multi)
}
inline void Share::set_multi(const char* value, size_t size) {
  set_has_multi();
  multi_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pool.proto.Share.multi)
}
inline ::std::string* Share::mutable_multi() {
  set_has_multi();
  // @@protoc_insertion_point(field_mutable:pool.proto.Share.multi)
  return multi_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Share::release_multi() {
  // @@protoc_insertion_point(field_release:pool.proto.Share.multi)
  clear_has_multi();
  return multi_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Share::set_allocated_multi(::std::string* multi) {
  if (multi != NULL) {
    set_has_multi();
  } else {
    clear_has_multi();
  }
  multi_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), multi);
  // @@protoc_insertion_point(field_set_allocated:pool.proto.Share.multi)
}

// optional string blockhash = 16;
inline bool Share::has_blockhash() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Share::set_has_blockhash() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Share::clear_has_blockhash() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Share::clear_blockhash() {
  blockhash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_blockhash();
}
inline const ::std::string& Share::blockhash() const {
  // @@protoc_insertion_point(field_get:pool.proto.Share.blockhash)
  return blockhash_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Share::set_blockhash(const ::std::string& value) {
  set_has_blockhash();
  blockhash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pool.proto.Share.blockhash)
}
inline void Share::set_blockhash(const char* value) {
  set_has_blockhash();
  blockhash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pool.proto.Share.blockhash)
}
inline void Share::set_blockhash(const char* value, size_t size) {
  set_has_blockhash();
  blockhash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pool.proto.Share.blockhash)
}
inline ::std::string* Share::mutable_blockhash() {
  set_has_blockhash();
  // @@protoc_insertion_point(field_mutable:pool.proto.Share.blockhash)
  return blockhash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Share::release_blockhash() {
  // @@protoc_insertion_point(field_release:pool.proto.Share.blockhash)
  clear_has_blockhash();
  return blockhash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Share::set_allocated_blockhash(::std::string* blockhash) {
  if (blockhash != NULL) {
    set_has_blockhash();
  } else {
    clear_has_blockhash();
  }
  blockhash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), blockhash);
  // @@protoc_insertion_point(field_set_allocated:pool.proto.Share.blockhash)
}

// required uint32 height = 20;
inline bool Share::has_height() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Share::set_has_height() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Share::clear_has_height() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Share::clear_height() {
  height_ = 0u;
  clear_has_height();
}
inline ::google::protobuf::uint32 Share::height() const {
  // @@protoc_insertion_point(field_get:pool.proto.Share.height)
  return height_;
}
inline void Share::set_height(::google::protobuf::uint32 value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.Share.height)
}

// required uint32 length = 21;
inline bool Share::has_length() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Share::set_has_length() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Share::clear_has_length() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Share::clear_length() {
  length_ = 0u;
  clear_has_length();
}
inline ::google::protobuf::uint32 Share::length() const {
  // @@protoc_insertion_point(field_get:pool.proto.Share.length)
  return length_;
}
inline void Share::set_length(::google::protobuf::uint32 value) {
  set_has_length();
  length_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.Share.length)
}

// required uint32 chaintype = 22;
inline bool Share::has_chaintype() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Share::set_has_chaintype() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Share::clear_has_chaintype() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Share::clear_chaintype() {
  chaintype_ = 0u;
  clear_has_chaintype();
}
inline ::google::protobuf::uint32 Share::chaintype() const {
  // @@protoc_insertion_point(field_get:pool.proto.Share.chaintype)
  return chaintype_;
}
inline void Share::set_chaintype(::google::protobuf::uint32 value) {
  set_has_chaintype();
  chaintype_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.Share.chaintype)
}

// required bool isblock = 23;
inline bool Share::has_isblock() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Share::set_has_isblock() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Share::clear_has_isblock() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Share::clear_isblock() {
  isblock_ = false;
  clear_has_isblock();
}
inline bool Share::isblock() const {
  // @@protoc_insertion_point(field_get:pool.proto.Share.isblock)
  return isblock_;
}
inline void Share::set_isblock(bool value) {
  set_has_isblock();
  isblock_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.Share.isblock)
}

// optional uint64 genvalue = 24;
inline bool Share::has_genvalue() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Share::set_has_genvalue() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Share::clear_has_genvalue() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Share::clear_genvalue() {
  genvalue_ = GOOGLE_ULONGLONG(0);
  clear_has_genvalue();
}
inline ::google::protobuf::uint64 Share::genvalue() const {
  // @@protoc_insertion_point(field_get:pool.proto.Share.genvalue)
  return genvalue_;
}
inline void Share::set_genvalue(::google::protobuf::uint64 value) {
  set_has_genvalue();
  genvalue_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.Share.genvalue)
}

inline const Share* Share::internal_default_instance() {
  return &Share_default_instance_.get();
}
// -------------------------------------------------------------------

// Request

// required .pool.proto.Request.Type type = 1;
inline bool Request::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::pool::proto::Request_Type Request::type() const {
  // @@protoc_insertion_point(field_get:pool.proto.Request.type)
  return static_cast< ::pool::proto::Request_Type >(type_);
}
inline void Request::set_type(::pool::proto::Request_Type value) {
  assert(::pool::proto::Request_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.Request.type)
}

// required uint32 reqid = 2;
inline bool Request::has_reqid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Request::set_has_reqid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Request::clear_has_reqid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Request::clear_reqid() {
  reqid_ = 0u;
  clear_has_reqid();
}
inline ::google::protobuf::uint32 Request::reqid() const {
  // @@protoc_insertion_point(field_get:pool.proto.Request.reqid)
  return reqid_;
}
inline void Request::set_reqid(::google::protobuf::uint32 value) {
  set_has_reqid();
  reqid_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.Request.reqid)
}

// optional uint32 version = 10;
inline bool Request::has_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Request::set_has_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Request::clear_has_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Request::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 Request::version() const {
  // @@protoc_insertion_point(field_get:pool.proto.Request.version)
  return version_;
}
inline void Request::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.Request.version)
}

// optional uint32 height = 11;
inline bool Request::has_height() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Request::set_has_height() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Request::clear_has_height() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Request::clear_height() {
  height_ = 0u;
  clear_has_height();
}
inline ::google::protobuf::uint32 Request::height() const {
  // @@protoc_insertion_point(field_get:pool.proto.Request.height)
  return height_;
}
inline void Request::set_height(::google::protobuf::uint32 value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.Request.height)
}

// optional bytes reqnonce = 12;
inline bool Request::has_reqnonce() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Request::set_has_reqnonce() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Request::clear_has_reqnonce() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Request::clear_reqnonce() {
  reqnonce_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_reqnonce();
}
inline const ::std::string& Request::reqnonce() const {
  // @@protoc_insertion_point(field_get:pool.proto.Request.reqnonce)
  return reqnonce_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Request::set_reqnonce(const ::std::string& value) {
  set_has_reqnonce();
  reqnonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pool.proto.Request.reqnonce)
}
inline void Request::set_reqnonce(const char* value) {
  set_has_reqnonce();
  reqnonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pool.proto.Request.reqnonce)
}
inline void Request::set_reqnonce(const void* value, size_t size) {
  set_has_reqnonce();
  reqnonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pool.proto.Request.reqnonce)
}
inline ::std::string* Request::mutable_reqnonce() {
  set_has_reqnonce();
  // @@protoc_insertion_point(field_mutable:pool.proto.Request.reqnonce)
  return reqnonce_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Request::release_reqnonce() {
  // @@protoc_insertion_point(field_release:pool.proto.Request.reqnonce)
  clear_has_reqnonce();
  return reqnonce_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Request::set_allocated_reqnonce(::std::string* reqnonce) {
  if (reqnonce != NULL) {
    set_has_reqnonce();
  } else {
    clear_has_reqnonce();
  }
  reqnonce_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), reqnonce);
  // @@protoc_insertion_point(field_set_allocated:pool.proto.Request.reqnonce)
}

// optional .pool.proto.Share share = 20;
inline bool Request::has_share() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Request::set_has_share() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Request::clear_has_share() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Request::clear_share() {
  if (share_ != NULL) share_->::pool::proto::Share::Clear();
  clear_has_share();
}
inline const ::pool::proto::Share& Request::share() const {
  // @@protoc_insertion_point(field_get:pool.proto.Request.share)
  return share_ != NULL ? *share_
                         : *::pool::proto::Share::internal_default_instance();
}
inline ::pool::proto::Share* Request::mutable_share() {
  set_has_share();
  if (share_ == NULL) {
    share_ = new ::pool::proto::Share;
  }
  // @@protoc_insertion_point(field_mutable:pool.proto.Request.share)
  return share_;
}
inline ::pool::proto::Share* Request::release_share() {
  // @@protoc_insertion_point(field_release:pool.proto.Request.share)
  clear_has_share();
  ::pool::proto::Share* temp = share_;
  share_ = NULL;
  return temp;
}
inline void Request::set_allocated_share(::pool::proto::Share* share) {
  delete share_;
  share_ = share;
  if (share) {
    set_has_share();
  } else {
    clear_has_share();
  }
  // @@protoc_insertion_point(field_set_allocated:pool.proto.Request.share)
}

// optional .pool.proto.ClientStats stats = 21;
inline bool Request::has_stats() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Request::set_has_stats() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Request::clear_has_stats() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Request::clear_stats() {
  if (stats_ != NULL) stats_->::pool::proto::ClientStats::Clear();
  clear_has_stats();
}
inline const ::pool::proto::ClientStats& Request::stats() const {
  // @@protoc_insertion_point(field_get:pool.proto.Request.stats)
  return stats_ != NULL ? *stats_
                         : *::pool::proto::ClientStats::internal_default_instance();
}
inline ::pool::proto::ClientStats* Request::mutable_stats() {
  set_has_stats();
  if (stats_ == NULL) {
    stats_ = new ::pool::proto::ClientStats;
  }
  // @@protoc_insertion_point(field_mutable:pool.proto.Request.stats)
  return stats_;
}
inline ::pool::proto::ClientStats* Request::release_stats() {
  // @@protoc_insertion_point(field_release:pool.proto.Request.stats)
  clear_has_stats();
  ::pool::proto::ClientStats* temp = stats_;
  stats_ = NULL;
  return temp;
}
inline void Request::set_allocated_stats(::pool::proto::ClientStats* stats) {
  delete stats_;
  stats_ = stats;
  if (stats) {
    set_has_stats();
  } else {
    clear_has_stats();
  }
  // @@protoc_insertion_point(field_set_allocated:pool.proto.Request.stats)
}

inline const Request* Request::internal_default_instance() {
  return &Request_default_instance_.get();
}
// -------------------------------------------------------------------

// ServerInfo

// required string host = 1;
inline bool ServerInfo::has_host() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerInfo::set_has_host() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerInfo::clear_has_host() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerInfo::clear_host() {
  host_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_host();
}
inline const ::std::string& ServerInfo::host() const {
  // @@protoc_insertion_point(field_get:pool.proto.ServerInfo.host)
  return host_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ServerInfo::set_host(const ::std::string& value) {
  set_has_host();
  host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pool.proto.ServerInfo.host)
}
inline void ServerInfo::set_host(const char* value) {
  set_has_host();
  host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pool.proto.ServerInfo.host)
}
inline void ServerInfo::set_host(const char* value, size_t size) {
  set_has_host();
  host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pool.proto.ServerInfo.host)
}
inline ::std::string* ServerInfo::mutable_host() {
  set_has_host();
  // @@protoc_insertion_point(field_mutable:pool.proto.ServerInfo.host)
  return host_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ServerInfo::release_host() {
  // @@protoc_insertion_point(field_release:pool.proto.ServerInfo.host)
  clear_has_host();
  return host_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ServerInfo::set_allocated_host(::std::string* host) {
  if (host != NULL) {
    set_has_host();
  } else {
    clear_has_host();
  }
  host_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), host);
  // @@protoc_insertion_point(field_set_allocated:pool.proto.ServerInfo.host)
}

// required uint32 router = 2;
inline bool ServerInfo::has_router() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerInfo::set_has_router() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServerInfo::clear_has_router() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServerInfo::clear_router() {
  router_ = 0u;
  clear_has_router();
}
inline ::google::protobuf::uint32 ServerInfo::router() const {
  // @@protoc_insertion_point(field_get:pool.proto.ServerInfo.router)
  return router_;
}
inline void ServerInfo::set_router(::google::protobuf::uint32 value) {
  set_has_router();
  router_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.ServerInfo.router)
}

// required uint32 pub = 3;
inline bool ServerInfo::has_pub() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServerInfo::set_has_pub() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServerInfo::clear_has_pub() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServerInfo::clear_pub() {
  pub_ = 0u;
  clear_has_pub();
}
inline ::google::protobuf::uint32 ServerInfo::pub() const {
  // @@protoc_insertion_point(field_get:pool.proto.ServerInfo.pub)
  return pub_;
}
inline void ServerInfo::set_pub(::google::protobuf::uint32 value) {
  set_has_pub();
  pub_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.ServerInfo.pub)
}

// required uint32 target = 4;
inline bool ServerInfo::has_target() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ServerInfo::set_has_target() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ServerInfo::clear_has_target() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ServerInfo::clear_target() {
  target_ = 0u;
  clear_has_target();
}
inline ::google::protobuf::uint32 ServerInfo::target() const {
  // @@protoc_insertion_point(field_get:pool.proto.ServerInfo.target)
  return target_;
}
inline void ServerInfo::set_target(::google::protobuf::uint32 value) {
  set_has_target();
  target_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.ServerInfo.target)
}

inline const ServerInfo* ServerInfo::internal_default_instance() {
  return &ServerInfo_default_instance_.get();
}
// -------------------------------------------------------------------

// Work

// required uint32 height = 1;
inline bool Work::has_height() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Work::set_has_height() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Work::clear_has_height() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Work::clear_height() {
  height_ = 0u;
  clear_has_height();
}
inline ::google::protobuf::uint32 Work::height() const {
  // @@protoc_insertion_point(field_get:pool.proto.Work.height)
  return height_;
}
inline void Work::set_height(::google::protobuf::uint32 value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.Work.height)
}

// required string merkle = 2;
inline bool Work::has_merkle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Work::set_has_merkle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Work::clear_has_merkle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Work::clear_merkle() {
  merkle_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_merkle();
}
inline const ::std::string& Work::merkle() const {
  // @@protoc_insertion_point(field_get:pool.proto.Work.merkle)
  return merkle_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Work::set_merkle(const ::std::string& value) {
  set_has_merkle();
  merkle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pool.proto.Work.merkle)
}
inline void Work::set_merkle(const char* value) {
  set_has_merkle();
  merkle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pool.proto.Work.merkle)
}
inline void Work::set_merkle(const char* value, size_t size) {
  set_has_merkle();
  merkle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pool.proto.Work.merkle)
}
inline ::std::string* Work::mutable_merkle() {
  set_has_merkle();
  // @@protoc_insertion_point(field_mutable:pool.proto.Work.merkle)
  return merkle_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Work::release_merkle() {
  // @@protoc_insertion_point(field_release:pool.proto.Work.merkle)
  clear_has_merkle();
  return merkle_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Work::set_allocated_merkle(::std::string* merkle) {
  if (merkle != NULL) {
    set_has_merkle();
  } else {
    clear_has_merkle();
  }
  merkle_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), merkle);
  // @@protoc_insertion_point(field_set_allocated:pool.proto.Work.merkle)
}

// required uint32 time = 3;
inline bool Work::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Work::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Work::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Work::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 Work::time() const {
  // @@protoc_insertion_point(field_get:pool.proto.Work.time)
  return time_;
}
inline void Work::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.Work.time)
}

// required uint32 bits = 4;
inline bool Work::has_bits() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Work::set_has_bits() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Work::clear_has_bits() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Work::clear_bits() {
  bits_ = 0u;
  clear_has_bits();
}
inline ::google::protobuf::uint32 Work::bits() const {
  // @@protoc_insertion_point(field_get:pool.proto.Work.bits)
  return bits_;
}
inline void Work::set_bits(::google::protobuf::uint32 value) {
  set_has_bits();
  bits_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.Work.bits)
}

inline const Work* Work::internal_default_instance() {
  return &Work_default_instance_.get();
}
// -------------------------------------------------------------------

// Reply

// required .pool.proto.Request.Type type = 1;
inline bool Reply::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Reply::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Reply::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Reply::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::pool::proto::Request_Type Reply::type() const {
  // @@protoc_insertion_point(field_get:pool.proto.Reply.type)
  return static_cast< ::pool::proto::Request_Type >(type_);
}
inline void Reply::set_type(::pool::proto::Request_Type value) {
  assert(::pool::proto::Request_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.Reply.type)
}

// required uint32 reqid = 2;
inline bool Reply::has_reqid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Reply::set_has_reqid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Reply::clear_has_reqid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Reply::clear_reqid() {
  reqid_ = 0u;
  clear_has_reqid();
}
inline ::google::protobuf::uint32 Reply::reqid() const {
  // @@protoc_insertion_point(field_get:pool.proto.Reply.reqid)
  return reqid_;
}
inline void Reply::set_reqid(::google::protobuf::uint32 value) {
  set_has_reqid();
  reqid_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.Reply.reqid)
}

// required .pool.proto.Reply.ErrType error = 10;
inline bool Reply::has_error() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Reply::set_has_error() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Reply::clear_has_error() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Reply::clear_error() {
  error_ = 0;
  clear_has_error();
}
inline ::pool::proto::Reply_ErrType Reply::error() const {
  // @@protoc_insertion_point(field_get:pool.proto.Reply.error)
  return static_cast< ::pool::proto::Reply_ErrType >(error_);
}
inline void Reply::set_error(::pool::proto::Reply_ErrType value) {
  assert(::pool::proto::Reply_ErrType_IsValid(value));
  set_has_error();
  error_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.Reply.error)
}

// optional string errstr = 11;
inline bool Reply::has_errstr() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Reply::set_has_errstr() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Reply::clear_has_errstr() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Reply::clear_errstr() {
  errstr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_errstr();
}
inline const ::std::string& Reply::errstr() const {
  // @@protoc_insertion_point(field_get:pool.proto.Reply.errstr)
  return errstr_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Reply::set_errstr(const ::std::string& value) {
  set_has_errstr();
  errstr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pool.proto.Reply.errstr)
}
inline void Reply::set_errstr(const char* value) {
  set_has_errstr();
  errstr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pool.proto.Reply.errstr)
}
inline void Reply::set_errstr(const char* value, size_t size) {
  set_has_errstr();
  errstr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pool.proto.Reply.errstr)
}
inline ::std::string* Reply::mutable_errstr() {
  set_has_errstr();
  // @@protoc_insertion_point(field_mutable:pool.proto.Reply.errstr)
  return errstr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Reply::release_errstr() {
  // @@protoc_insertion_point(field_release:pool.proto.Reply.errstr)
  clear_has_errstr();
  return errstr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Reply::set_allocated_errstr(::std::string* errstr) {
  if (errstr != NULL) {
    set_has_errstr();
  } else {
    clear_has_errstr();
  }
  errstr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), errstr);
  // @@protoc_insertion_point(field_set_allocated:pool.proto.Reply.errstr)
}

// optional .pool.proto.ServerInfo sinfo = 20;
inline bool Reply::has_sinfo() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Reply::set_has_sinfo() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Reply::clear_has_sinfo() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Reply::clear_sinfo() {
  if (sinfo_ != NULL) sinfo_->::pool::proto::ServerInfo::Clear();
  clear_has_sinfo();
}
inline const ::pool::proto::ServerInfo& Reply::sinfo() const {
  // @@protoc_insertion_point(field_get:pool.proto.Reply.sinfo)
  return sinfo_ != NULL ? *sinfo_
                         : *::pool::proto::ServerInfo::internal_default_instance();
}
inline ::pool::proto::ServerInfo* Reply::mutable_sinfo() {
  set_has_sinfo();
  if (sinfo_ == NULL) {
    sinfo_ = new ::pool::proto::ServerInfo;
  }
  // @@protoc_insertion_point(field_mutable:pool.proto.Reply.sinfo)
  return sinfo_;
}
inline ::pool::proto::ServerInfo* Reply::release_sinfo() {
  // @@protoc_insertion_point(field_release:pool.proto.Reply.sinfo)
  clear_has_sinfo();
  ::pool::proto::ServerInfo* temp = sinfo_;
  sinfo_ = NULL;
  return temp;
}
inline void Reply::set_allocated_sinfo(::pool::proto::ServerInfo* sinfo) {
  delete sinfo_;
  sinfo_ = sinfo;
  if (sinfo) {
    set_has_sinfo();
  } else {
    clear_has_sinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:pool.proto.Reply.sinfo)
}

// optional .pool.proto.Work work = 21;
inline bool Reply::has_work() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Reply::set_has_work() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Reply::clear_has_work() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Reply::clear_work() {
  if (work_ != NULL) work_->::pool::proto::Work::Clear();
  clear_has_work();
}
inline const ::pool::proto::Work& Reply::work() const {
  // @@protoc_insertion_point(field_get:pool.proto.Reply.work)
  return work_ != NULL ? *work_
                         : *::pool::proto::Work::internal_default_instance();
}
inline ::pool::proto::Work* Reply::mutable_work() {
  set_has_work();
  if (work_ == NULL) {
    work_ = new ::pool::proto::Work;
  }
  // @@protoc_insertion_point(field_mutable:pool.proto.Reply.work)
  return work_;
}
inline ::pool::proto::Work* Reply::release_work() {
  // @@protoc_insertion_point(field_release:pool.proto.Reply.work)
  clear_has_work();
  ::pool::proto::Work* temp = work_;
  work_ = NULL;
  return temp;
}
inline void Reply::set_allocated_work(::pool::proto::Work* work) {
  delete work_;
  work_ = work;
  if (work) {
    set_has_work();
  } else {
    clear_has_work();
  }
  // @@protoc_insertion_point(field_set_allocated:pool.proto.Reply.work)
}

// optional .pool.proto.Block block = 22;
inline bool Reply::has_block() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Reply::set_has_block() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Reply::clear_has_block() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Reply::clear_block() {
  if (block_ != NULL) block_->::pool::proto::Block::Clear();
  clear_has_block();
}
inline const ::pool::proto::Block& Reply::block() const {
  // @@protoc_insertion_point(field_get:pool.proto.Reply.block)
  return block_ != NULL ? *block_
                         : *::pool::proto::Block::internal_default_instance();
}
inline ::pool::proto::Block* Reply::mutable_block() {
  set_has_block();
  if (block_ == NULL) {
    block_ = new ::pool::proto::Block;
  }
  // @@protoc_insertion_point(field_mutable:pool.proto.Reply.block)
  return block_;
}
inline ::pool::proto::Block* Reply::release_block() {
  // @@protoc_insertion_point(field_release:pool.proto.Reply.block)
  clear_has_block();
  ::pool::proto::Block* temp = block_;
  block_ = NULL;
  return temp;
}
inline void Reply::set_allocated_block(::pool::proto::Block* block) {
  delete block_;
  block_ = block;
  if (block) {
    set_has_block();
  } else {
    clear_has_block();
  }
  // @@protoc_insertion_point(field_set_allocated:pool.proto.Reply.block)
}

inline const Reply* Reply::internal_default_instance() {
  return &Reply_default_instance_.get();
}
// -------------------------------------------------------------------

// ReqStats

// required .pool.proto.Request.Type reqtype = 1;
inline bool ReqStats::has_reqtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqStats::set_has_reqtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqStats::clear_has_reqtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqStats::clear_reqtype() {
  reqtype_ = 0;
  clear_has_reqtype();
}
inline ::pool::proto::Request_Type ReqStats::reqtype() const {
  // @@protoc_insertion_point(field_get:pool.proto.ReqStats.reqtype)
  return static_cast< ::pool::proto::Request_Type >(reqtype_);
}
inline void ReqStats::set_reqtype(::pool::proto::Request_Type value) {
  assert(::pool::proto::Request_Type_IsValid(value));
  set_has_reqtype();
  reqtype_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.ReqStats.reqtype)
}

// required .pool.proto.Reply.ErrType errtype = 2;
inline bool ReqStats::has_errtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqStats::set_has_errtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqStats::clear_has_errtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqStats::clear_errtype() {
  errtype_ = 0;
  clear_has_errtype();
}
inline ::pool::proto::Reply_ErrType ReqStats::errtype() const {
  // @@protoc_insertion_point(field_get:pool.proto.ReqStats.errtype)
  return static_cast< ::pool::proto::Reply_ErrType >(errtype_);
}
inline void ReqStats::set_errtype(::pool::proto::Reply_ErrType value) {
  assert(::pool::proto::Reply_ErrType_IsValid(value));
  set_has_errtype();
  errtype_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.ReqStats.errtype)
}

// required uint32 count = 3;
inline bool ReqStats::has_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqStats::set_has_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqStats::clear_has_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqStats::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 ReqStats::count() const {
  // @@protoc_insertion_point(field_get:pool.proto.ReqStats.count)
  return count_;
}
inline void ReqStats::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.ReqStats.count)
}

inline const ReqStats* ReqStats::internal_default_instance() {
  return &ReqStats_default_instance_.get();
}
// -------------------------------------------------------------------

// ServerStats

// required string name = 1;
inline bool ServerStats::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerStats::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerStats::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerStats::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& ServerStats::name() const {
  // @@protoc_insertion_point(field_get:pool.proto.ServerStats.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ServerStats::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pool.proto.ServerStats.name)
}
inline void ServerStats::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pool.proto.ServerStats.name)
}
inline void ServerStats::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pool.proto.ServerStats.name)
}
inline ::std::string* ServerStats::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:pool.proto.ServerStats.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ServerStats::release_name() {
  // @@protoc_insertion_point(field_release:pool.proto.ServerStats.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ServerStats::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:pool.proto.ServerStats.name)
}

// required uint32 thread = 2;
inline bool ServerStats::has_thread() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerStats::set_has_thread() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServerStats::clear_has_thread() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServerStats::clear_thread() {
  thread_ = 0u;
  clear_has_thread();
}
inline ::google::protobuf::uint32 ServerStats::thread() const {
  // @@protoc_insertion_point(field_get:pool.proto.ServerStats.thread)
  return thread_;
}
inline void ServerStats::set_thread(::google::protobuf::uint32 value) {
  set_has_thread();
  thread_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.ServerStats.thread)
}

// required uint32 workers = 10;
inline bool ServerStats::has_workers() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServerStats::set_has_workers() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServerStats::clear_has_workers() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServerStats::clear_workers() {
  workers_ = 0u;
  clear_has_workers();
}
inline ::google::protobuf::uint32 ServerStats::workers() const {
  // @@protoc_insertion_point(field_get:pool.proto.ServerStats.workers)
  return workers_;
}
inline void ServerStats::set_workers(::google::protobuf::uint32 value) {
  set_has_workers();
  workers_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.ServerStats.workers)
}

// required uint32 latency = 11;
inline bool ServerStats::has_latency() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ServerStats::set_has_latency() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ServerStats::clear_has_latency() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ServerStats::clear_latency() {
  latency_ = 0u;
  clear_has_latency();
}
inline ::google::protobuf::uint32 ServerStats::latency() const {
  // @@protoc_insertion_point(field_get:pool.proto.ServerStats.latency)
  return latency_;
}
inline void ServerStats::set_latency(::google::protobuf::uint32 value) {
  set_has_latency();
  latency_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.ServerStats.latency)
}

// required float cpd = 12;
inline bool ServerStats::has_cpd() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ServerStats::set_has_cpd() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ServerStats::clear_has_cpd() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ServerStats::clear_cpd() {
  cpd_ = 0;
  clear_has_cpd();
}
inline float ServerStats::cpd() const {
  // @@protoc_insertion_point(field_get:pool.proto.ServerStats.cpd)
  return cpd_;
}
inline void ServerStats::set_cpd(float value) {
  set_has_cpd();
  cpd_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.ServerStats.cpd)
}

// repeated .pool.proto.ReqStats reqstats = 20;
inline int ServerStats::reqstats_size() const {
  return reqstats_.size();
}
inline void ServerStats::clear_reqstats() {
  reqstats_.Clear();
}
inline const ::pool::proto::ReqStats& ServerStats::reqstats(int index) const {
  // @@protoc_insertion_point(field_get:pool.proto.ServerStats.reqstats)
  return reqstats_.Get(index);
}
inline ::pool::proto::ReqStats* ServerStats::mutable_reqstats(int index) {
  // @@protoc_insertion_point(field_mutable:pool.proto.ServerStats.reqstats)
  return reqstats_.Mutable(index);
}
inline ::pool::proto::ReqStats* ServerStats::add_reqstats() {
  // @@protoc_insertion_point(field_add:pool.proto.ServerStats.reqstats)
  return reqstats_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::pool::proto::ReqStats >*
ServerStats::mutable_reqstats() {
  // @@protoc_insertion_point(field_mutable_list:pool.proto.ServerStats.reqstats)
  return &reqstats_;
}
inline const ::google::protobuf::RepeatedPtrField< ::pool::proto::ReqStats >&
ServerStats::reqstats() const {
  // @@protoc_insertion_point(field_list:pool.proto.ServerStats.reqstats)
  return reqstats_;
}

inline const ServerStats* ServerStats::internal_default_instance() {
  return &ServerStats_default_instance_.get();
}
// -------------------------------------------------------------------

// Data

// optional .pool.proto.Share share = 1;
inline bool Data::has_share() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Data::set_has_share() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Data::clear_has_share() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Data::clear_share() {
  if (share_ != NULL) share_->::pool::proto::Share::Clear();
  clear_has_share();
}
inline const ::pool::proto::Share& Data::share() const {
  // @@protoc_insertion_point(field_get:pool.proto.Data.share)
  return share_ != NULL ? *share_
                         : *::pool::proto::Share::internal_default_instance();
}
inline ::pool::proto::Share* Data::mutable_share() {
  set_has_share();
  if (share_ == NULL) {
    share_ = new ::pool::proto::Share;
  }
  // @@protoc_insertion_point(field_mutable:pool.proto.Data.share)
  return share_;
}
inline ::pool::proto::Share* Data::release_share() {
  // @@protoc_insertion_point(field_release:pool.proto.Data.share)
  clear_has_share();
  ::pool::proto::Share* temp = share_;
  share_ = NULL;
  return temp;
}
inline void Data::set_allocated_share(::pool::proto::Share* share) {
  delete share_;
  share_ = share;
  if (share) {
    set_has_share();
  } else {
    clear_has_share();
  }
  // @@protoc_insertion_point(field_set_allocated:pool.proto.Data.share)
}

// optional .pool.proto.ClientStats clientstats = 2;
inline bool Data::has_clientstats() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Data::set_has_clientstats() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Data::clear_has_clientstats() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Data::clear_clientstats() {
  if (clientstats_ != NULL) clientstats_->::pool::proto::ClientStats::Clear();
  clear_has_clientstats();
}
inline const ::pool::proto::ClientStats& Data::clientstats() const {
  // @@protoc_insertion_point(field_get:pool.proto.Data.clientstats)
  return clientstats_ != NULL ? *clientstats_
                         : *::pool::proto::ClientStats::internal_default_instance();
}
inline ::pool::proto::ClientStats* Data::mutable_clientstats() {
  set_has_clientstats();
  if (clientstats_ == NULL) {
    clientstats_ = new ::pool::proto::ClientStats;
  }
  // @@protoc_insertion_point(field_mutable:pool.proto.Data.clientstats)
  return clientstats_;
}
inline ::pool::proto::ClientStats* Data::release_clientstats() {
  // @@protoc_insertion_point(field_release:pool.proto.Data.clientstats)
  clear_has_clientstats();
  ::pool::proto::ClientStats* temp = clientstats_;
  clientstats_ = NULL;
  return temp;
}
inline void Data::set_allocated_clientstats(::pool::proto::ClientStats* clientstats) {
  delete clientstats_;
  clientstats_ = clientstats;
  if (clientstats) {
    set_has_clientstats();
  } else {
    clear_has_clientstats();
  }
  // @@protoc_insertion_point(field_set_allocated:pool.proto.Data.clientstats)
}

// optional .pool.proto.ServerStats serverstats = 3;
inline bool Data::has_serverstats() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Data::set_has_serverstats() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Data::clear_has_serverstats() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Data::clear_serverstats() {
  if (serverstats_ != NULL) serverstats_->::pool::proto::ServerStats::Clear();
  clear_has_serverstats();
}
inline const ::pool::proto::ServerStats& Data::serverstats() const {
  // @@protoc_insertion_point(field_get:pool.proto.Data.serverstats)
  return serverstats_ != NULL ? *serverstats_
                         : *::pool::proto::ServerStats::internal_default_instance();
}
inline ::pool::proto::ServerStats* Data::mutable_serverstats() {
  set_has_serverstats();
  if (serverstats_ == NULL) {
    serverstats_ = new ::pool::proto::ServerStats;
  }
  // @@protoc_insertion_point(field_mutable:pool.proto.Data.serverstats)
  return serverstats_;
}
inline ::pool::proto::ServerStats* Data::release_serverstats() {
  // @@protoc_insertion_point(field_release:pool.proto.Data.serverstats)
  clear_has_serverstats();
  ::pool::proto::ServerStats* temp = serverstats_;
  serverstats_ = NULL;
  return temp;
}
inline void Data::set_allocated_serverstats(::pool::proto::ServerStats* serverstats) {
  delete serverstats_;
  serverstats_ = serverstats;
  if (serverstats) {
    set_has_serverstats();
  } else {
    clear_has_serverstats();
  }
  // @@protoc_insertion_point(field_set_allocated:pool.proto.Data.serverstats)
}

inline const Data* Data::internal_default_instance() {
  return &Data_default_instance_.get();
}
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace pool

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::pool::proto::Signal_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pool::proto::Signal_Type>() {
  return ::pool::proto::Signal_Type_descriptor();
}
template <> struct is_proto_enum< ::pool::proto::Request_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pool::proto::Request_Type>() {
  return ::pool::proto::Request_Type_descriptor();
}
template <> struct is_proto_enum< ::pool::proto::Reply_ErrType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pool::proto::Reply_ErrType>() {
  return ::pool::proto::Reply_ErrType_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protocol_2eproto__INCLUDED
